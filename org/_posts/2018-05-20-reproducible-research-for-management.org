#+STARTUP: showall
#+OPTIONS: toc:nil
#+EXCLUDE_TAGS: noexport

#+BEGIN_EXPORT html
---
layout: post
title: Reproducible Research and Software Development Methods for Management tasks
categories: org-mode Emacs reproducible-research
---
#+END_EXPORT

* Introduction
The administrative tasks in today's workplace are steadily growing,
whether you are a manager or just driven by requirements from
management. The introduction of IT in these processes has the big
potential of easing some of the tedious tasks through automatization and integration, but it seems
that we are a long way away from that. The segregated toolchains, lack of compatibility of interfaces and
different work cultures rather have resulted in an increase of stress and very often require substantial
human effort, and very often in a form which is not sustainable.

What can we as scientists and software engineers do to improve our
situation? I am asking this in the most pragmatic sense and I will
show what I found to work for me in the last years. So, this is not
about demanding that the world suddenly become completely reasonable,
establish compatible standards and adopt harmonized best practices
that everybody agrees on. I would like to show that one can start
small by using smart and flexible frameworks for easing these tasks
for oneself or for one's group, and hope that by example these
practices will find the support of others.

So let's see what we can do based on the toolchains that we learn in
data science and software engineering. I will use [[https://www.gnu.org/software/emacs/][GNU Emacs]] to present
my current workflow, but the ideas are generic and you may find other solutions.

* The problem
  The sad reality is that a lot of management documents come in the form of Excel and Powerpoint.
  While I think that Excel is a great software that enables people to obtain results fast and
  in a nicely interactive way, it's work model for complex or long-living documents is deficient.
  Let's take as an example the planning of a complex budget.
  
  Reasons
  - changes to the document are difficult to track in a transparent and comprehensible way.
    Compare this to the established way we track software changes in revision control
    systems like git. There we not only track each change, but also the motivations for it.
  - as the Excel documents gets bigger, it tend to contain many sheets with lots of references.
    Errors easily creep in and are difficult to spot (e.g. numbers outside of formula cell ranges
    which are silently ignored). Compare this to unit tests and integration tests that we use
    continually in software development and scientific programming.
  - there is a lot of copy & paste going on, from the Excel sheet into
    a word document used as a report, to a Powerpoint to do a
    presentation. In data science we also take care to track the
    changes to data (data provenance) and to make sure that a document
    references a dataset in a clearly identifyable way.

* Three Engineering Musketeers to the Rescue
** Reproducible Research
   *Reproducible research* is an important topic in today's IT research and it
   also has an important significance for our society and the ethics of conducting research
   and being able to present and conserve the underlying data and arguments, so that
   others can follow the analysis of the data and understand the conclusions.
   Today's interest in SW containers like Docker is in part also powered by the desire
   to conserve a computational environment in an easily sharable form.

   It is closely related to the idea of *literate programing* that
   Donald Knuth launched with [[http://www.literateprogramming.com/knuthweb.pdf][his seminal article]] in 1984. Literate
   programming environments allow the free mixing of code parts with
   extensive documentation parts. The source of the document will
   contain all necessary data as well as the code for manipulating the
   data to produce results and plots. It will also contain all the text
   and argumentation. Out of this document one then can generate a nice
   publication, but also other derived information (e.g. a standalone
   software program and a data set, or an excel sheet to give to
   management).

   [[https://orgmode.org/][Org mode for Emacs]] is one such environment, but there are also
   others (e.g. look at [[https://reproducibleresearch.net/links/][this list of links]] maintained by
   reproducibleresearch.net). Another very modern open source
   environments in rapid development is given by [[http://jupyter.org/][Jupyter]]. This is very popular
   among scientists. These frameworks are not only great for publishing research
   in a reproducible manner, but also are becoming one of the best teaching aids,
   since students can easily experiment with these self-contained documents.
  
** Software best practices

   Changes should be tracked by *revision control systems* like [[https://git-scm.com/][git]]. An optimal
   tracking is possible, if the differences from one version of a document to the
   next can be easily visualized. This usually requires that the document format
   is an easy text based format and not some protected and secret or even a binary
   format. Even more, not only can we track changes through time, but we also
   can add metadata in the form of comments that motivate why the changes were
   made.

   Humans will make errors, and each time one does something non-trivial, especially
   when it is of a repetitive nature, errors easily creep in. Also, doing changes
   in one part of a complex thing may cause other parts of our wonderful ivory tower
   computation to collapse. So, in SW engineering the ideas of *unit and intergration tests*
   has become an accepted paradigm.

   *Versioning.* Documents should be versioned in a clearly defined way similar as
   to what we do with widely accepted standards like [[https://semver.org/][semantic versioning]].

   *Templating and Repetition* Repetitive parts in a document, e.g. if for a budget
   of many services I would like to have the same chapter structure with tables,
   plots, etc., this should be generated by a single code or template block.
   Senseless repetition or copy paste is useless human toil and leads to errors.
   A later change should not have to be done in a hundered places.

** Data Analysis Tools
   There exists a plethora of programming libraries to deal with data
   in all of its forms. In particular, Python is a language which has been
   increasingly adopted by the scientific world. It is expressive and provides
   frameworks for interactive data analysis. But there are other solutions as
   well, e.g. [[https://www.r-project.org/][the R project]].

   Since I am a Python person, I will recommend the following libraries for tackling
   the kind of management related problems we are talking about
   - [[https://pandas.pydata.org/][Pandas]]: easy-to-use data structures and data analysis tools
   - [[http://www.numpy.org/][numpy]]: fundamental package for scientific computing. Used by Pandas
   - [[https://matplotlib.org/][matplotlib]] and [[https://seaborn.pydata.org/][seaborn]] for visualization

* An example workflow using Emacs Org mode and python
  
  In the following, I will demonstrate the planning workflow that I arrived to over the
  last years using Emacs and its fabulous Org-Mode

** planning with an outliner
   Outliners are ideal for jotting down thoughts and ideas. Some people may prefer mind-maps, but
   in the end the underlying data structures are mostly identical. The outliner lists are
   certainly more efficient for a proficient typist and are easily mixed with other parts of a
   text.

   I have used outlines for years for planning project and service
   budgets for our scientific computing section. Sub-items can be used to add additional
   information to a top level list item or to provide new information.

   Please bear with me if I choose an example not from IT.

   #+NAME: lstShipGalante
   - Our worminger service (service: SvcWorminger)
     - item: A world class worm (Terces: 300, recurrence: 5, type: livestock)
       - [2018-05-10 Thu] I got offered a better price (Terces: 280)
       - Seems that today's worms last a year less than in the good old times (recurrence: 4)
     - item: high class fluke cleaner (Terces: 20, recurrence: 1, type: ops)
     - item: worm fodder (Terces: 50, recurrence: 1, type: ops)
     - The needed manpower (type: fte, recurrence: 1)
       - item: a competent worminger for 1y (Terces: 80)
       - item: an apprentice worminger for 1y (Terces: 30)
   - Onboard Restaurant service (service: SvcRestaurant)
     - item: furniture (Terces: 80, recurrence: 8, type: investment)
     - item: tableware breakage (Terces: 20, recurrence: 1, type: ops)
       - [2018-05-18 Fri] I found a cheaper supplier (Terces: 16)
     - Manpower (type: fte, recurrence: 1)
       - item: One head steward for 1y (Terces: 60)
       - item: 2 stewards for 1y (Terces: 90)

** Generate a table from the outline

   In order to perform computations, we would usually like to have a
   computationally more suitable format like a table. So, at some
   point I started thinking about defining useful semantics for
   automatically deriving a table from such a planning list. The
   following example shows what I came up with. I am publishing this now
   as an Emacs package [[https://github.com/dfeich/org-listcruncher][org-listcruncher]] (I am just preparing to getting it
   ready for submission as anotherMELPA package).

   The following Org mode code block will cause the list I defined above to
   be rendered into a table.
   : ,#+BEGIN_SRC elisp :results value :var lname="lstShipGalante" order='("service" "descr" "Terces")
   :  (org-listcruncher-to-table lname order)
   : ,#+END_SRC
   

   #+NAME: srcTable
   #+HEADER: :var lname="lstShipGalante" order='("service" "descr" "Terces")
   #+BEGIN_SRC elisp :results value  :exports results
    (org-listcruncher-to-table lname order)
   #+END_SRC

   #+RESULTS: srcTable
   | service       | descr                          | Terces | recurrence | type       |
   |---------------+--------------------------------+--------+------------+------------|
   | SvcWorminger  | A world class worm             |    280 |          4 | livestock  |
   | SvcWorminger  | high class fluke cleaner       |     20 |          1 | ops        |
   | SvcWorminger  | worm fodder                    |     50 |          1 | ops        |
   | SvcWorminger  | a competent worminger for 1y   |     80 |          1 | fte        |
   | SvcWorminger  | an apprentice worminger for 1y |     30 |          1 | fte        |
   | SvcRestaurant | furniture                      |     80 |          8 | investment |
   | SvcRestaurant | tableware breakage             |     16 |          1 | ops        |
   | SvcRestaurant | One head steward for 1y        |     60 |          1 | fte        |
   | SvcRestaurant | 2 stewards for 1y              |     90 |          1 | fte        |


   The important thing is, that the list that is the source for the table values can
   later be further edited, and all derivative results will change accordingly.
   The audit trail is conserved in the list, and naturally it will also be conserved
   in the commits into the revision control system. 

** data analysis and visualization

   Now, as the data is in an easily accessible form, we can use the Babel feature of org
   mode to read in the table into a python code block and perform some Pandas data
   manipulation magic on it.

   #+HEADER: :var tbl=srcTable
   #+BEGIN_SRC python :results output raw drawer :colnames no :post lobPostAlignTables(*this*)
     import orgbabelhelper as obh
     import pandas as pd

     df = obh.orgtable_to_dataframe(tbl, index="descr")
     df["Terces"] = pd.to_numeric(df["Terces"])
     dfgrp = df.groupby(["service", "type"], as_index=False).sum()
     dfgrp = dfgrp[["service", "type", "Terces"]]
     print(obh.dataframe_to_orgtable(dfgrp, index=False, caption="Costs per type and service",
				     name="tblGrouped"))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   #+CAPTION: Costs per type and service
   #+NAME: tblGrouped
   | service       | type       | Terces |
   |---------------+------------+--------|
   | SvcRestaurant | fte        |    150 |
   | SvcRestaurant | investment |     80 |
   | SvcRestaurant | ops        |     16 |
   | SvcWorminger  | fte        |    110 |
   | SvcWorminger  | livestock  |    280 |
   | SvcWorminger  | ops        |     70 |

   :END:

   And another little code block lets us visualize cuts of the data.

   #+HEADER: :var fname="assets/images/listcruncher-grouped.png" tbl=tblGrouped
   #+BEGIN_SRC python :results file :colnames no
     import pandas as pd
     import orgbabelhelper as obh
     import matplotlib.pyplot as plt
     import seaborn; seaborn.set()

     df = obh.orgtable_to_dataframe(tbl, index="service")
     df[df["type"] == "fte"].plot(kind="bar", rot=0, legend=False)

     plt.title('Costs per year for Services on the Galante')
     plt.ylabel('Terces')
     plt.xlabel('')
     plt.tight_layout()

     plt.savefig(fname)
     return fname
   #+END_SRC

   #+RESULTS:
   [[file:assets/images/listcruncher-grouped.png]]


* notes                                                            :noexport:
  - Reproducible research methodology for management tasks
    - what can we scientists and software engineers do to handle management tasks in a better
      way and to reduce the time effort
    - We just do what we know best. We utilize the toolchains and best
      practices we have learned for software development and data
      analysis to organize our management tasks.
  - The sad reality: Management by Excel
    - Excel good program that enables people to do fast exploration, but
      - bad at tracking changes in a transparent way
      - difficult to prevent errors as projects grow
      - excel expertise to do things well as big an effort as learning programming
      - data grave
      - management by copy paste of data instead of a single, well tended data source
      - motivations and explanations often kept separate from the data
  - Planning with an outliner
    - audit trail
    - tracking changes and the motivations associated with them. Leaving old information
      visible to make the process transparent and understandable to others
    - how to derive a format from the outliner that can be used by data analysis tools? Want to
      conserve the semantics inherent in hierarchical lists?
  - reproducible research / literate programming
    - being able to track changes and their motivations with revision control systems
    - data and code in the same document
    - being able to generate different outputs from the same document, so that also
      management is satisfied (Excel)
    - sustainable
    - references
      - Knuth, D. E. (1984). Literate programming. The Computer Journal , 27(2):97–111
  - An example of my planning
